### 三者的关联关系（核心记忆点）
1. **变量类型 → 存储类型**：  
   - 全局变量：由EVM管理，无需关心存储位置。  
   - 状态变量：**默认在storage**（永久存储）。  
   - 局部变量：  
     - 值类型：默认在**栈**（临时存储）。  也可以指定memory或storage
     - 引用类型：必须显式指定（`memory`临时存储，或`storage`引用状态变量）。  


2. **数据类型 → 存储类型**：  
   - 值类型：可在栈、memory、storage中存储（赋值时均为值复制）。  
   - 引用类型：  
     - `mapping`：**只能在storage**（状态变量或引用状态变量的局部变量）。  
     - 数组/结构体：可在memory、storage、calldata中存储（赋值行为取决于存储位置）。  


3. **存储类型 → 赋值行为**：  
   - 不同存储位置之间赋值：**值复制**（如storage→memory，或memory→storage）。  
   - 相同存储位置之间赋值：  
     - storage→storage：**引用传递**（修改新变量会影响原变量）。  
     - memory→memory：值复制（引用类型在memory中赋值是复制）。  

#### 总结
`mapping` 之所以只能用 `storage`，是因为：  
- 其“哈希寻址、稀疏存储”的底层机制，只有 `storage`（区块链永久存储）能支持；  
- `memory` 的线性临时存储模型与 `mapping` 的设计目标完全不兼容；  
- Solidity 语言规范为了保证安全性和gas效率，强制限制了 `mapping` 的存储位置。  

这一设计确保了 `mapping` 在区块链环境中能以最低的gas成本实现高效的键值对查询，同时符合区块链“永久存储”的核心特性。

##### 额外限制：Solidity 语言规范的强制要求
即使从技术上假设 `memory` 可以支持 `mapping`，Solidity 语言规范也明确禁止：  
- 状态变量中的 `mapping` 默认为 `storage`（必须永久存储在区块链上）。  
- 函数内的局部变量若为 `mapping`，必须显式指定为 `storage`，且只能 **引用已存在的 `storage` mapping**（不能在 `memory` 中创建新的 `mapping`）。  

例如，以下代码是合法的（局部变量引用状态变量的 `mapping`）：
```solidity
contract Example {
    mapping(uint => address) public myMapping; // 状态变量，默认storage
    
    function test() public {
        mapping(uint => address) storage m = myMapping; // 局部变量，引用storage中的mapping
        m[1] = msg.sender; // 实际修改的是myMapping
    }
}
```

而以下代码会直接编译报错（试图在 `memory` 中创建 `mapping`）：
```solidity
function invalid() public {
    mapping(uint => address) memory m; // 错误：mapping不能在memory中声明
}
```
