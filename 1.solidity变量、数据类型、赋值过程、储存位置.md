### **一、变量（Variables）**
Solidity 中的变量根据作用域和可见性可分为以下几类：

1. **状态变量（State Variables）**
   - 存储在区块链上的变量，属于合约的永久存储。
   - 消耗 gas（区块链存储资源），修改时会写入区块链。
   - 声明位置：合约内部，函数外部。
   ```solidity
   contract MyContract {
       uint public myNumber; // 状态变量，默认值为 0
   }
   ```

2. **局部变量（Local Variables）**
   - 仅在函数执行时存在，存储在内存（memory）中。
   - 不消耗 gas（除非涉及状态修改），函数执行结束后销毁。
   - 声明位置：函数内部。
   ```solidity
   function add(uint a, uint b) public pure returns (uint) {
       uint sum = a + b; // 局部变量
       return sum;
   }
   ```

3. **全局变量（Global Variables）**
   - 由以太坊虚拟机（EVM）提供的特殊变量，用于获取区块链信息。
   - 无需声明，直接使用。
   例如：
   - `msg.sender`：当前调用者的地址
   - `block.timestamp`：当前区块的时间戳
   - `gasleft()`：剩余 gas 数量


### **二、数据类型（Data Types）**
Solidity 数据类型按「赋值方式」分为两大类，核心区别是：**值类型赋值时拷贝数据，引用类型赋值时默认传递引用（需显式控制拷贝）**。

#### **1. 值类型（Value Types）**
赋值时直接拷贝数据，修改新变量不会影响原变量。支持存储在 `storage`/`memory`/`stack`


- **整数（Integers）**
  - `int`/`uint`：有符号/无符号整数（默认 256 位）。
  - 可指定位数：`int8`~`int256`（步长 8）、`uint8`~`uint256`。
  - 示例：`uint256 balance; int128 temperature;`

- **布尔值（Boolean）**
  - `bool`：取值为 `true` 或 `false`。
  - 示例：`bool isActive = true;`

- **地址（Address）**
  - 存储以太坊地址（20 字节），用于标识账户或合约。
  - `address`：基础地址类型。
  - `address payable`：可接收以太币的地址（包含 `transfer`/`send` 方法）。
  - 示例：`address payable owner = payable(msg.sender);`

- **固定大小字节数组**
  - `bytes1`~`bytes32`：存储固定长度的字节数据（1~32 字节）。
  - 示例：`bytes32 hash = keccak256("hello");`

- **枚举（Enums）**
  - 自定义离散值类型，用于限制变量取值范围。
  ```solidity
  enum Status { Pending, Approved, Rejected }
  Status public currentStatus = Status.Pending;
  ```

- **函数类型（Function Types）**
  - 表示函数，可以作为参数或返回值
  ```solidity
  function myFunction() external pure returns (uint) {
      return 100;
  }
  ```

#### **2. 引用类型（Reference Types）**
赋值时默认传递「引用」（即新变量指向原数据的存储位置），修改新变量会影响原变量。【引用类型必须指定存储位置，仅支持存储在】 `storage` 或 `memory`（`mapping` 仅支持 `storage`）。

- **数组（Arrays）**
  - 固定大小数组：`uint[5] public fixedArray;`
  - 动态数组：`uint[] public dynamicArray;`
  - 字符串：`string public myString = "Hello";`（特殊的动态字节数组）

- **结构体（Structs）**
  - 自定义复合数据类型
  ```solidity
  struct Person {
      string name;
      uint age;
  }
  Person public person = Person("Alice", 30);
  ```

- **映射（Mappings）**
  - 键值对存储结构，类似哈希表，仅能作为状态变量。
  ```solidity
  mapping(address => uint) public balances; // 地址到余额的映射
  function setBalance(address user, uint amount) public {
      balances[user] = amount; // 赋值
  }
  ```


### **三、变量+数据类型在evm中的存储位置（核心记忆点）**
1. **变量类型 → 存储类型**：  
   - 全局变量：由EVM管理，无需关心存储位置。  
   - 状态变量：**默认在storage**（永久存储）。  
   - 局部变量：  
     - 值类型：默认在**栈**（临时存储）。  也可以指定memory或storage
     - 引用类型：必须显式指定（`memory`临时存储，或`storage`引用状态变量）。  


2. **数据类型 → 存储类型**：  
   - 值类型：可在栈、memory、storage中存储（赋值时均为值复制）。  
   - 引用类型：  
     - `mapping`：**只能在storage**（状态变量或引用状态变量的局部变量）。  
     - 数组/结构体：可在memory、storage、calldata中存储（赋值行为取决于存储位置）。  


### **四、赋值过程**
1. **基本类型赋值**：【所有情况都是直接复制值】，修改新变量不影响原变量。
   ```solidity
   uint a = 5;
   uint b = a; // b = 5
   b = 10; // a 仍为 5
   ```

2. **引用类型赋值**：
   - 同存储位置：传递引用（修改新变量会影响原变量）。
		【存在特殊情况】
   - 不同存储位置：复制值（修改新变量不影响原变量）。
   
| 赋值方向          | 行为描述                                                                 |
|-------------------|--------------------------------------------------------------------------|
| storage → storage | 引用传递（不拷贝数据，两个变量指向同一存储位置）                         |
| memory → memory   | 引用传递（【仅对于动态数组和字符串，固定大小类型会拷贝】）                   |
| calldata → memory | 拷贝数据（calldata 不可修改，赋值到 memory 后生成独立副本）              |
| storage ↔ memory  | 拷贝数据（跨位置赋值时，会生成完整数据副本）                             |



### 五、映射（Mapping）的特殊规则
映射（`mapping`）是特殊的引用类型，其赋值规则与其他类型不同：
1. 映射只能【存储】在 `storage` 中（不能在 `memory` 或 `calldata` 中声明）。
2. 映射之间的【赋值】（`storage → storage`）是**引用传递**，修改会相互影响。
3. 无法直接将映射的【赋值】从 `storage` 拷贝到 `memory`（需手动遍历键值对复制）。

```solidity
contract MappingExample {
    mapping(uint => uint) public map1;
    mapping(uint => uint) public map2;

    function test() public {
        map1[1] = 100;
        map2 = map1; // storage → storage：引用传递
        map2[1] = 200; // 修改 map2 会影响 map1
        // 此时 map1[1] 和 map2[1] 均为 200
    }
}
```

`mapping` 之所以只能用 `storage`，是因为：  
- 其“哈希寻址、稀疏存储”的底层机制，只有 `storage`（区块链永久存储）能支持；  
- `memory` 的线性临时存储模型与 `mapping` 的设计目标完全不兼容；  
- Solidity 语言规范为了保证安全性和gas效率，强制限制了 `mapping` 的存储位置。  



##### 额外限制：Solidity 语言规范的强制要求
即使从技术上假设 `memory` 可以支持 `mapping`，Solidity 语言规范也明确禁止：  
- 状态变量中的 `mapping` 默认为 `storage`（必须永久存储在区块链上）。  
- 函数内的局部变量若为 `mapping`，必须显式指定为 `storage`，且只能 **引用已存在的 `storage` mapping**（不能在 `memory` 中创建新的 `mapping`）。  

例如，以下代码是合法的（局部变量引用状态变量的 `mapping`）：
```solidity
contract Example {
    mapping(uint => address) public myMapping; // 状态变量，默认storage
    
    function test() public {
        mapping(uint => address) storage m = myMapping; // 局部变量，引用storage中的mapping
        m[1] = msg.sender; // 实际修改的是myMapping
    }
}
```

而以下代码会直接编译报错（试图在 `memory` 中创建 `mapping`）：
```solidity
function invalid() public {
    mapping(uint => address) memory m; // 错误：mapping不能在memory中声明
}
```
