### 一、以太坊账户和账户状态？
以太坊中的账户分为两种类型，**“账户状态”指的是描述账户当前状况的所有数据集合**，不同类型的账户状态包含的信息不同：

1. **外部账户（EOA，Externally Owned Account）**  
   由私钥控制的普通账户（如用户钱包），其状态包含：  
   - `nonce`：已发送的交易数量（防止重放攻击）；  
   - `balance`：账户中的以太币余额（以wei为单位）；  
   - `codeHash`：固定为0x0（因为EOA没有合约代码）；  
   - `storageHash`：固定为0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421（空的存储根哈希，因为EOA没有状态变量）。  

2. **合约账户（Contract Account）**  
   部署在链上的智能合约，其状态包含：  
   - `nonce`：合约创建的合约数量（较少用到）；  
   - `balance`：合约账户中的以太币余额；  
   - `codeHash`：合约字节码的哈希值（指向链上存储的合约代码）；  
   - `storageHash`：合约状态变量的存储根哈希（指向存储状态变量的Merkle Patricia树）。  

简言之，“账户状态”是账户的“身份信息+资产信息+数据信息”的总和，是区块链全局状态的组成部分。


### 二、【区块链全局状态】与stateDB的关系？
【区块链全局状态】就是逻辑状态树（【都是MPT 树】）和合约二进制代码。它们的核心作用是：通过哈希嵌套的树结构，让全局状态具备 【“可验证性”】（任何微小修改都会导致根哈希变化）和 【“高效查询性”】（类似字典的键值查找）。
**stateDB（状态数据库，是一个【键值数据库】）是以太坊节点本地用于【区块链全局状态】的数据库**（通常基于LevelDB实现，不同客户端可能有差异）。

#### 1. 账户状态树（Account State Trie）
- **作用**：记录全网所有账户（外部账户 EOA 和合约账户）的当前状态。
- **结构**：
  - 键（Key）：账户地址的 Keccak256 哈希（`keccak256(address)`）。
  - 值（Value）：账户状态的四元组（`nonce`、`balance`、`codeHash`、`storageHash`）的 RLP 编码。
- **根哈希**：树的根节点哈希（`stateRoot`）记录在每个区块的区块头中，代表当前区块链的全局账户状态。

#### 2. 交易树（Transaction Trie）
- **作用**：记录一个区块中所有交易的集合，用于验证区块内交易的完整性。
- **结构**：
  - 键（Key）：交易在区块中的索引（0、1、2...）。
  - 值（Value）：交易数据的 RLP 编码。
- **根哈希**：交易树根哈希（`transactionsRoot`）记录在区块头中，确保区块内交易未被篡改。

#### 3. 收据树（Receipt Trie）
- **作用**：记录一个区块中所有交易执行后的收据（如是否成功、日志 `log` 等）。
- **结构**：
  - 键（Key）：交易在区块中的索引（与交易树对应）。
  - 值（Value）：交易收据数据的 RLP 编码。
- **根哈希**：收据树根哈希（`receiptsRoot`）记录在区块头中，用于验证交易执行结果。

#### 4.合约代码（Contract Code）
- **作用**：存储智能合约的字节码（部署后不可修改），供EVM执行合约时加载使用。
- **结构**：
  - 键（Key）：合约字节码的Keccak256哈希（codeHash）。
  - 值（Value）：合约编译后的完整字节码（二进制原始数据）。
- **关联方式**：合约代码的键（codeHash）作为合约账户状态四元组的字段之一，记录在账户状态树中，通过该哈希可直接从stateDB查询对应的合约代码。

#### 5. 合约存储树（Storage Trie）
- **作用**：【每个合约账户拥有独立的存储树，也是mpt树】，记录该合约的所有状态变量（如 `mapping`、`uint` 等）。
- **结构**：
  - 键（Key）：状态变量存储位置的哈希（例如，`mapping` 的键哈希与插槽索引组合的哈希）。
  - 值（Value）：状态变量值的 RLP 编码。
- **根哈希**：每个合约的存储树根哈希（`storageHash`）作为该合约账户状态的一部分，记录在账户状态树中。


### 三、这些数据如何在“内存中存储”？
“内存中存储”指的是**数据在节点运行时或EVM执行时的临时存储**，不持久化，生命周期有限，主要用于提升效率：

#### 1. 节点内存缓存（Node Cache）  
- 全节点为了快速处理交易和区块，会将常用的账户状态（如活跃账户的余额、合约代码）缓存到内存中，避免频繁从磁盘数据库读取。  
- 例如，当验证一个转账交易时，节点会先从内存缓存中读取发送方账户的`nonce`和`balance`，若缓存中没有再从磁盘的stateDB加载。  
【mpt树不一定非要是常驻节点内存的】


#### 2. EVM执行时的内存（EVM Memory）  
- 当合约执行交易时，EVM会为当前交易创建临时内存（即“EVM内存”），用于存储执行过程中的临时数据（如函数参数、局部变量的引用类型）。  
- 例如，合约函数中定义的`string memory s = "hello"`，`s`的值会存储在EVM内存中，函数执行结束后内存会被释放，不影响链上存储。  
- 注意：EVM内存与“链上存储”完全隔离，链上存储的状态变量（storage）需要显式修改才会被持久化（且消耗gas）。  


### 四、链上存储≠区块文件，两者是“变更指令”与“最终状态”的关系
- **区块文件**：确实存储“增量交易”，但它的核心是**记录状态变更的“指令”**，而非最终状态。  
  每个区块包含：区块头（时间、难度、`stateRoot`等元数据）、交易列表（用户发起的转账/合约调用等操作）、叔块信息等。这些交易本质是“如何修改状态”的指令（比如“从A向B转1ETH”“调用合约C的函数D并传入参数E”），而非修改后的最终结果。

- **链上存储**：是一个更宽泛的概念，既包括区块文件（历史交易指令），也包括**所有交易执行后形成的“全局最终状态”**（账户余额、合约代码、状态变量等）。  
  打个比方：区块文件类似“账本的交易记录页”（记录“谁转给谁多少钱”），而链上存储还包括“每个人当前的总余额”（即交易执行后的结果）。  


### 五、小结：
区块链全局状态：3个树+合约代码+每个合约的mpt（MPT 树：是组织最终状态的 “逻辑索引结构”，其节点数据物理存储在 stateDB 中，而非仅在内存。）
stateDB：是链上存储在节点本地的物理实现，它维护了多棵逻辑上的 Merkle Patricia Tree（MPT），这些树共同构成了区块链的全局状态。

区块文件：存储 “状态变更的指令”（交易），是历史操作的记录。
链上存储：包括区块文件（历史指令）和 最终状态（账户状态树、存储树等MPT和合约代码），是 “指令 + 结果” 的总和。最终持久化到节点的 stateDB 中。

内存存储：运行时的概念，包括节点的内存缓存（加速访问）和 EVM 执行时的临时内存（处理交易中间状态），生命周期短暂。


